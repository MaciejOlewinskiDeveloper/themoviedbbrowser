package net.olewinski.themoviedbbrowser.ui.screens

import android.app.SearchManager
import android.database.Cursor
import android.os.Bundle
import android.view.*
import androidx.appcompat.widget.SearchView
import androidx.cursoradapter.widget.CursorAdapter
import androidx.cursoradapter.widget.SimpleCursorAdapter
import androidx.fragment.app.Fragment
import androidx.lifecycle.Observer
import androidx.lifecycle.ViewModelProvider
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.LinearLayoutManager
import net.olewinski.themoviedbbrowser.R
import net.olewinski.themoviedbbrowser.application.TheMovieDbBrowserApplication
import net.olewinski.themoviedbbrowser.cloud.DataLoadingState
import net.olewinski.themoviedbbrowser.databinding.FragmentMoviesListBinding
import net.olewinski.themoviedbbrowser.ui.adapters.MoviesListAdapter
import net.olewinski.themoviedbbrowser.viewmodels.MovieDetailsNavigationRequest
import net.olewinski.themoviedbbrowser.viewmodels.MoviesListViewModel
import net.olewinski.themoviedbbrowser.viewmodels.SelectedMovieViewModel

/**
 * Movies list screen.
 */
class MoviesListFragment : Fragment() {

    private lateinit var moviesListBinding: FragmentMoviesListBinding
    private lateinit var moviesListAdapter: MoviesListAdapter

    private lateinit var moviesListViewModel: MoviesListViewModel
    private lateinit var selectedMovieViewModel: SelectedMovieViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setHasOptionsMenu(true)

        activity?.let { activity ->
            val applicationComponent =
                (activity.applicationContext as TheMovieDbBrowserApplication).applicationComponent

            moviesListViewModel = ViewModelProvider(
                viewModelStore,
                applicationComponent.getMoviesListViewModelFactory()
            ).get(MoviesListViewModel::class.java)

            selectedMovieViewModel = ViewModelProvider(
                activity.viewModelStore,
                applicationComponent.getSelectedMovieViewModelFactory()
            ).get(SelectedMovieViewModel::class.java)
        } ?: throw RuntimeException("Lack of Activity!")
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        moviesListBinding = FragmentMoviesListBinding.inflate(inflater, container, false)
        moviesListBinding.lifecycleOwner = viewLifecycleOwner

        return moviesListBinding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        // Handling navigation requests generated by view model
        moviesListViewModel.navigationRequest.observe(
            viewLifecycleOwner,
            Observer { navigationRequestOneTimeEvent ->
                navigationRequestOneTimeEvent.getContent()?.let { navigationRequest ->
                    when (navigationRequest) {
                        is MovieDetailsNavigationRequest -> {
                            selectedMovieViewModel.selectMovie(navigationRequest.movieData)
                            findNavController().navigate(MoviesListFragmentDirections.actionMoviesCollectionFragmentToMovieDetailsFragment())
                        }
                    }
                }
            })

        // Creating adapter for RecyclerView
        moviesListAdapter = MoviesListAdapter(viewLifecycleOwner, { item ->
            moviesListViewModel.onItemClicked(item)
        }, { item ->
            moviesListViewModel.onItemFavouriteToggleClicked(item)
        }, {
            moviesListViewModel.retry()
        })

        // Configuring RecyclerView
        moviesListBinding.moviesList.apply {
            adapter = moviesListAdapter
            layoutManager = LinearLayoutManager(context)
            addItemDecoration(DividerItemDecoration(context, LinearLayoutManager.VERTICAL))
        }

        // Observing list with movies
        moviesListViewModel.pagedMoviesData.observe(viewLifecycleOwner, Observer { movieDataList ->
            moviesListAdapter.submitList(movieDataList)
        })

        // Observing network state
        moviesListViewModel.networkState.observe(viewLifecycleOwner, Observer { networkState ->
            moviesListAdapter.updateNetworkState(networkState)
        })

        // Observing refresh state
        moviesListViewModel.refreshState.observe(viewLifecycleOwner, Observer { refreshState ->
            moviesListBinding.swipeToRefresh.isRefreshing = refreshState == DataLoadingState.LOADING
        })

        // Handling swipe-to-refresh gesture
        moviesListBinding.swipeToRefresh.setOnRefreshListener {
            moviesListViewModel.refreshMoviesData()
        }
    }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.movies_list_menu, menu)

        initSearchItem(menu.findItem(R.id.search_item).actionView as SearchView)

        super.onCreateOptionsMenu(menu, inflater)
    }

    override fun onOptionsItemSelected(item: MenuItem) = when (item.itemId) {
        R.id.refresh_item -> {
            moviesListViewModel.refreshMoviesData()

            true
        }

        else -> {
            super.onOptionsItemSelected(item)
        }
    }

    private fun initSearchItem(searchView: SearchView) {
        // Creating suggestions adapter for SearchView with empty set of suggestions
        val simpleCursorAdapter = SimpleCursorAdapter(
            requireContext(),
            android.R.layout.simple_dropdown_item_1line,
            null,
            arrayOf(SearchManager.SUGGEST_COLUMN_TEXT_1),
            intArrayOf(android.R.id.text1),
            CursorAdapter.FLAG_REGISTER_CONTENT_OBSERVER
        )

        // Observing remembered last typed search query to update SearchView's look
        moviesListViewModel.lastTypedSearchQuery?.also { currentSearchQuery ->
            searchView.isIconified = false
            searchView.setQuery(currentSearchQuery, false)
        }

        searchView.apply {
            suggestionsAdapter = simpleCursorAdapter
            isSubmitButtonEnabled = true

            // Observing user's input
            setOnQueryTextListener(object : SearchView.OnQueryTextListener {
                override fun onQueryTextChange(newText: String?): Boolean {
                    moviesListViewModel.requestSearchSuggestionsUpdate(newText)

                    return true
                }

                override fun onQueryTextSubmit(query: String?): Boolean {
                    // If user clicked on "Search", we're searching!
                    moviesListViewModel.searchMovies(query)

                    return true
                }
            })

            setOnSuggestionListener(object : SearchView.OnSuggestionListener {
                override fun onSuggestionSelect(position: Int) = false

                override fun onSuggestionClick(position: Int): Boolean {
                    // This is safe, as we know that this Cursor comes from view model, and we also
                    // know that view model creates it as MatrixCursor (backed by just an array).
                    // However, it's not a good design - we should not make assumptions what Cursor
                    // we get (if it would be cursor from database, then it won't be safe to extract
                    // anything from it in UI thread). This is simple example-only app that won't be
                    // growing so we can leave it as is. But in commercial development, we couldn't
                    // do such things even in case of small apps - we never know business decisions
                    // if app won't grow in the future.
                    val cursor = suggestionsAdapter.getItem(position) as Cursor
                    val selection =
                        cursor.getString(cursor.getColumnIndex(SearchManager.SUGGEST_COLUMN_TEXT_1))

                    setQuery(selection, false)

                    return true
                }
            })

            setOnCloseListener {
                // If user closed this view, we need to stop showing found movies, we need to go
                // back to regular "Now Playing" list
                moviesListViewModel.getNowPlaying()
                false
            }
        }

        // Observing search suggestions
        moviesListViewModel.searchSuggestions.observe(
            viewLifecycleOwner,
            Observer { searchSuggestions ->
                searchView.suggestionsAdapter.apply {
                    changeCursor(searchSuggestions)
                    notifyDataSetChanged()
                }
            })
    }
}
